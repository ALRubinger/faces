<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
   "http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd" []>
<chapter id="components">
	<title>Seam Faces Components</title>
	<para>While Seam Faces does not provide layout components or other UI-design related features, it does provide
	functional components designed to make developing JSF applications easier, more functional, more scalable, and
	more practical.</para>
	<para>
	For layout and design components, take a look at <ulink url="http://jboss.org/richfaces">RichFaces</ulink>, a 
	UI component library specifically tailored for easy, rich web-interfaces.
	</para>
	<section id="basicUsage">
		<title>Introduction</title>
		<para>
			In order to use the Seam Faces components, you must first add the namespace to your view file, 
			just like the standard JSF component libraries.
			
			<programlisting><![CDATA[<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:h="http://java.sun.com/jsf/html"
      xmlns:f="http://java.sun.com/jsf/core"
      xmlns:s="http://jboss.com/products/seam/faces"
      xmlns:ui="http://java.sun.com/jsf/facelets">
      
      <h1>This is a view using Seam Faces</h1>
      <h:outputText value="#{bean.sayHello()}" />
      
</html>]]></programlisting>
			<tip>
				<para>
					All Seam Faces components use the same namespace: 
					<literal>http://jboss.com/products/seam/faces</literal>
				</para>
			</tip>
		</para>
	</section>
	<section id="validateForm">
		<title>&lt;s:validateForm&gt;</title>
		<para>
			On many occasions you might find yourself needing to compare the values of multiple input fields
			on a given page submit: confirming a password; re-enter password; address lookups; and so on. 
			
			Performing cross-field form validation is simple - just place the &lt;s:validateForm&gt; component
			in the form you wish to validate, then attach your custom Validator.
			<programlisting><![CDATA[<h:form id="locationForm">
     <h:inputText id="city" value="#{bean.city}" />
     <h:inputText id="state" value="#{bean.state}" />
     <h:inputText id="zip" value="#{bean.zip}" />
     <h:commandButton id="submit" value="Submit" action="#{bean.submitPost}" />
                  
      <s:validateForm validatorId="locationValidator" />
</h:form>]]></programlisting> 



			The corresponding Validator for the example above would look something like this:
			<programlisting>@FacesValidator("locationValidator")
public class LocationValidator implements Validator
{
   @Inject
   Directory directory;

   @Inject
   @InputField
   private Object city;

   @Inject
   @InputField
   private Object state;

   @Inject
   @InputField
   private ZipCode zip;

   @Override
   public void validate(final FacesContext context, final UIComponent comp, final Object values) throws ValidatorException
   {
      if(!directory.exists(city, state, zip))
      {
         throw new ValidatorException(new FacesMessage("Sorry, that location is not in our database. Please try again."));
      }
   }
}</programlisting>
		</para>
		
			<tip>
				<para>
		You may inject the correct type directly.
				<programlisting>@Inject
@InputField
private ZipCode zip;</programlisting>
				</para>
			</tip>
		
		<para>
			Notice that the IDs of the inputText components match the IDs of your Validator 
			@InputFields; each @Inject @InputField member will be injected with the value of the form input field
			who's ID matches the name of the variable.
		</para>
		<para>
			In other words - the name of the @InputField annotated member variable will automatically
			be matched to the ID of the input component, unless overridden by using a field
			ID alias (see below.) 
			
			<programlisting><![CDATA[<h:form id="locationForm">
     <h:inputText id="cityId" value="#{bean.city}" />
     <h:inputText id="stateId" value="#{bean.state}" />
     <h:inputText id="zip" value="#{bean.zip}" />
     <h:commandButton id="submit" value="Submit" action="#{bean.submitPost}" />
                  
      <s:validateForm fields="city=cityId state=stateId" validatorId="locationValidator" />
</h:form>]]></programlisting>

			Notice that "zip" will still be referenced normally; you need only
			specify aliases for fields that differ in name from the Validator @InputFields.
			
		</para>
		<para>

			<tip>
				<para>
					<literal>Using @InputField("customID")</literal> with an ID override can also be used to 
					specify a custom ID, instead of using the default: the name of the field. This gives you
					the ability to change the name of the private field, without worrying about changing the
					name of input fields in the View itself.
				<programlisting>@Inject
@InputField("state")
private String sectorTwo;</programlisting>
				</para>
			</tip>
		</para>
	</section>
	
	
	
	
	<section id="viewaction">
		<title>&lt;s:viewAction&gt;</title>
		<para>
			ViewAction doc
			<programlisting><![CDATA[<s:viewAction> example]]></programlisting>
			<tip>
				<para>
					Maybe a tip here?
				</para>
			</tip>
		</para>
	</section>
</chapter>